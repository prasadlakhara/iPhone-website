import{R as L,L as C,C as T,S as K,O as Z,H as U,F as H,M as W,P as V,W as $,U as B,a as ee,D as te,b as E,c as z,T as A,I as ae,d as re,B as ie,e as ne,f as P,g as se,h as D,i as oe,j as de,k as N,l as le,V as O,N as he}from"./three-BF1wJDGd.js";const J=(p,e,t)=>{let a;switch(p){case P:a=new Uint8ClampedArray(e*t*4);break;case U:a=new Uint16Array(e*t*4);break;case ne:a=new Uint32Array(e*t*4);break;case ie:a=new Int8Array(e*t*4);break;case re:a=new Int16Array(e*t*4);break;case ae:a=new Int32Array(e*t*4);break;case H:a=new Float32Array(e*t*4);break;default:throw new Error("Unsupported data type")}return a};let R;const fe=(p,e,t,a)=>{if(R!==void 0)return R;const n=new $(1,1,a);e.setRenderTarget(n);const r=new W(new V,new se({color:16777215}));e.render(r,t),e.setRenderTarget(null);const o=J(p,n.width,n.height);return e.readRenderTargetPixels(n,0,0,n.width,n.height,o),n.dispose(),r.geometry.dispose(),r.material.dispose(),R=o[0]!==0,R};class G{constructor(e){var t,a,n,r,o,s,g,l,f,h,i,M,y,w,v,c;this._rendererIsDisposable=!1,this._supportsReadPixels=!0,this.render=()=>{this._renderer.setRenderTarget(this._renderTarget);try{this._renderer.render(this._scene,this._camera)}catch(_){throw this._renderer.setRenderTarget(null),_}this._renderer.setRenderTarget(null)},this._width=e.width,this._height=e.height,this._type=e.type,this._colorSpace=e.colorSpace;const F={format:L,depthBuffer:!1,stencilBuffer:!1,type:this._type,colorSpace:this._colorSpace,anisotropy:((t=e.renderTargetOptions)===null||t===void 0?void 0:t.anisotropy)!==void 0?(a=e.renderTargetOptions)===null||a===void 0?void 0:a.anisotropy:1,generateMipmaps:((n=e.renderTargetOptions)===null||n===void 0?void 0:n.generateMipmaps)!==void 0?(r=e.renderTargetOptions)===null||r===void 0?void 0:r.generateMipmaps:!1,magFilter:((o=e.renderTargetOptions)===null||o===void 0?void 0:o.magFilter)!==void 0?(s=e.renderTargetOptions)===null||s===void 0?void 0:s.magFilter:C,minFilter:((g=e.renderTargetOptions)===null||g===void 0?void 0:g.minFilter)!==void 0?(l=e.renderTargetOptions)===null||l===void 0?void 0:l.minFilter:C,samples:((f=e.renderTargetOptions)===null||f===void 0?void 0:f.samples)!==void 0?(h=e.renderTargetOptions)===null||h===void 0?void 0:h.samples:void 0,wrapS:((i=e.renderTargetOptions)===null||i===void 0?void 0:i.wrapS)!==void 0?(M=e.renderTargetOptions)===null||M===void 0?void 0:M.wrapS:T,wrapT:((y=e.renderTargetOptions)===null||y===void 0?void 0:y.wrapT)!==void 0?(w=e.renderTargetOptions)===null||w===void 0?void 0:w.wrapT:T};if(this._material=e.material,e.renderer?this._renderer=e.renderer:(this._renderer=G.instantiateRenderer(),this._rendererIsDisposable=!0),this._scene=new K,this._camera=new Z,this._camera.position.set(0,0,10),this._camera.left=-.5,this._camera.right=.5,this._camera.top=.5,this._camera.bottom=-.5,this._camera.updateProjectionMatrix(),!fe(this._type,this._renderer,this._camera,F)){let _;switch(this._type){case U:_=this._renderer.extensions.has("EXT_color_buffer_float")?H:void 0;break}_!==void 0?(console.warn(`This browser does not support reading pixels from ${this._type} RenderTargets, switching to ${H}`),this._type=_):(this._supportsReadPixels=!1,console.warn("This browser dos not support toArray or toDataTexture, calls to those methods will result in an error thrown"))}this._quad=new W(new V,this._material),this._quad.geometry.computeBoundingBox(),this._scene.add(this._quad),this._renderTarget=new $(this.width,this.height,F),this._renderTarget.texture.mapping=((v=e.renderTargetOptions)===null||v===void 0?void 0:v.mapping)!==void 0?(c=e.renderTargetOptions)===null||c===void 0?void 0:c.mapping:B}static instantiateRenderer(){const e=new ee;return e.setSize(128,128),e}toArray(){if(!this._supportsReadPixels)throw new Error("Can't read pixels in this browser");const e=J(this._type,this._width,this._height);return this._renderer.readRenderTargetPixels(this._renderTarget,0,0,this._width,this._height,e),e}toDataTexture(e){const t=new te(this.toArray(),this.width,this.height,L,this._type,(e==null?void 0:e.mapping)||B,(e==null?void 0:e.wrapS)||T,(e==null?void 0:e.wrapT)||T,(e==null?void 0:e.magFilter)||C,(e==null?void 0:e.minFilter)||C,(e==null?void 0:e.anisotropy)||1,E);return t.generateMipmaps=(e==null?void 0:e.generateMipmaps)!==void 0?e==null?void 0:e.generateMipmaps:!1,t}disposeOnDemandRenderer(){this._renderer.setRenderTarget(null),this._rendererIsDisposable&&(this._renderer.dispose(),this._renderer.forceContextLoss())}dispose(e){this.disposeOnDemandRenderer(),e&&this.renderTarget.dispose(),this.material instanceof z&&Object.values(this.material.uniforms).forEach(t=>{t.value instanceof A&&t.value.dispose()}),Object.values(this.material).forEach(t=>{t instanceof A&&t.dispose()}),this.material.dispose(),this._quad.geometry.dispose()}get width(){return this._width}set width(e){this._width=e,this._renderTarget.setSize(this._width,this._height)}get height(){return this._height}set height(e){this._height=e,this._renderTarget.setSize(this._width,this._height)}get renderer(){return this._renderer}get renderTarget(){return this._renderTarget}set renderTarget(e){this._renderTarget=e,this._width=e.width,this._height=e.height}get material(){return this._material}get type(){return this._type}get colorSpace(){return this._colorSpace}}const ge=`
varying vec2 vUv;

void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`,pe=`
// min half float value
#define HALF_FLOAT_MIN vec3( -65504, -65504, -65504 )
// max half float value
#define HALF_FLOAT_MAX vec3( 65504, 65504, 65504 )

uniform sampler2D sdr;
uniform sampler2D gainMap;
uniform vec3 gamma;
uniform vec3 offsetHdr;
uniform vec3 offsetSdr;
uniform vec3 gainMapMin;
uniform vec3 gainMapMax;
uniform float weightFactor;

varying vec2 vUv;

void main() {
  vec3 rgb = texture2D( sdr, vUv ).rgb;
  vec3 recovery = texture2D( gainMap, vUv ).rgb;
  vec3 logRecovery = pow( recovery, gamma );
  vec3 logBoost = gainMapMin * ( 1.0 - logRecovery ) + gainMapMax * logRecovery;
  vec3 hdrColor = (rgb + offsetSdr) * exp2( logBoost * weightFactor ) - offsetHdr;
  vec3 clampedHdrColor = max( HALF_FLOAT_MIN, min( HALF_FLOAT_MAX, hdrColor ));
  gl_FragColor = vec4( clampedHdrColor , 1.0 );
}
`;class ce extends z{constructor({gamma:e,offsetHdr:t,offsetSdr:a,gainMapMin:n,gainMapMax:r,maxDisplayBoost:o,hdrCapacityMin:s,hdrCapacityMax:g,sdr:l,gainMap:f}){super({name:"GainMapDecoderMaterial",vertexShader:ge,fragmentShader:pe,uniforms:{sdr:{value:l},gainMap:{value:f},gamma:{value:new O(1/e[0],1/e[1],1/e[2])},offsetHdr:{value:new O().fromArray(t)},offsetSdr:{value:new O().fromArray(a)},gainMapMin:{value:new O().fromArray(n)},gainMapMax:{value:new O().fromArray(r)},weightFactor:{value:(Math.log2(o)-s)/(g-s)}},blending:he,depthTest:!1,depthWrite:!1}),this._maxDisplayBoost=o,this._hdrCapacityMin=s,this._hdrCapacityMax=g,this.needsUpdate=!0,this.uniformsNeedUpdate=!0}get sdr(){return this.uniforms.sdr.value}set sdr(e){this.uniforms.sdr.value=e}get gainMap(){return this.uniforms.gainMap.value}set gainMap(e){this.uniforms.gainMap.value=e}get offsetHdr(){return this.uniforms.offsetHdr.value.toArray()}set offsetHdr(e){this.uniforms.offsetHdr.value.fromArray(e)}get offsetSdr(){return this.uniforms.offsetSdr.value.toArray()}set offsetSdr(e){this.uniforms.offsetSdr.value.fromArray(e)}get gainMapMin(){return this.uniforms.gainMapMin.value.toArray()}set gainMapMin(e){this.uniforms.gainMapMin.value.fromArray(e)}get gainMapMax(){return this.uniforms.gainMapMax.value.toArray()}set gainMapMax(e){this.uniforms.gainMapMax.value.fromArray(e)}get gamma(){const e=this.uniforms.gamma.value;return[1/e.x,1/e.y,1/e.z]}set gamma(e){const t=this.uniforms.gamma.value;t.x=1/e[0],t.y=1/e[1],t.z=1/e[2]}get hdrCapacityMin(){return this._hdrCapacityMin}set hdrCapacityMin(e){this._hdrCapacityMin=e,this.calculateWeight()}get hdrCapacityMax(){return this._hdrCapacityMax}set hdrCapacityMax(e){this._hdrCapacityMax=e,this.calculateWeight()}get maxDisplayBoost(){return this._maxDisplayBoost}set maxDisplayBoost(e){this._maxDisplayBoost=Math.max(1,Math.min(65504,e)),this.calculateWeight()}calculateWeight(){const e=(Math.log2(this._maxDisplayBoost)-this._hdrCapacityMin)/(this._hdrCapacityMax-this._hdrCapacityMin);this.uniforms.weightFactor.value=Math.max(0,Math.min(1,e))}}class X extends Error{}class j extends Error{}const S=(p,e,t)=>{var a;let n;const r=(a=p.attributes.getNamedItem(e))===null||a===void 0?void 0:a.nodeValue;if(r)n=r;else{const o=p.getElementsByTagName(e)[0];if(o){const s=o.getElementsByTagName("rdf:li");if(s.length===3)n=Array.from(s).map(g=>g.innerHTML);else throw new Error(`Gainmap metadata contains an array of items for ${e} but its length is not 3`)}else{if(t)return t;throw new Error(`Can't find ${e} in gainmap metadata`)}}return n},me=p=>{var e,t;let a;typeof TextDecoder<"u"?a=new TextDecoder().decode(p):a=p.toString();let n=a.indexOf("<x:xmpmeta");const r=new DOMParser;for(;n!==-1;){const o=a.indexOf("x:xmpmeta>",n);a.slice(n,o+10);const s=a.slice(n,o+10);try{const l=r.parseFromString(s,"text/xml").getElementsByTagName("rdf:Description")[0],f=S(l,"hdrgm:GainMapMin","0"),h=S(l,"hdrgm:GainMapMax"),i=S(l,"hdrgm:Gamma","1"),M=S(l,"hdrgm:OffsetSDR","0.015625"),y=S(l,"hdrgm:OffsetHDR","0.015625");let w=(e=l.attributes.getNamedItem("hdrgm:HDRCapacityMin"))===null||e===void 0?void 0:e.nodeValue;w||(w="0");const v=(t=l.attributes.getNamedItem("hdrgm:HDRCapacityMax"))===null||t===void 0?void 0:t.nodeValue;if(!v)throw new Error("Incomplete gainmap metadata");return{gainMapMin:Array.isArray(f)?f.map(c=>parseFloat(c)):[parseFloat(f),parseFloat(f),parseFloat(f)],gainMapMax:Array.isArray(h)?h.map(c=>parseFloat(c)):[parseFloat(h),parseFloat(h),parseFloat(h)],gamma:Array.isArray(i)?i.map(c=>parseFloat(c)):[parseFloat(i),parseFloat(i),parseFloat(i)],offsetSdr:Array.isArray(M)?M.map(c=>parseFloat(c)):[parseFloat(M),parseFloat(M),parseFloat(M)],offsetHdr:Array.isArray(y)?y.map(c=>parseFloat(c)):[parseFloat(y),parseFloat(y),parseFloat(y)],hdrCapacityMin:parseFloat(w),hdrCapacityMax:parseFloat(v)}}catch{}n=a.indexOf("<x:xmpmeta",o)}};class ue{constructor(e){this.options={debug:e&&e.debug!==void 0?e.debug:!1,extractFII:e&&e.extractFII!==void 0?e.extractFII:!0,extractNonFII:e&&e.extractNonFII!==void 0?e.extractNonFII:!0}}extract(e){return new Promise((t,a)=>{const n=this.options.debug,r=new DataView(e.buffer);if(r.getUint16(0)!==65496){a(new Error("Not a valid jpeg"));return}const o=r.byteLength;let s=2,g=0,l;for(;s<o;){if(++g>250){a(new Error(`Found no marker after ${g} loops 😵`));return}if(r.getUint8(s)!==255){a(new Error(`Not a valid marker at offset 0x${s.toString(16)}, found: 0x${r.getUint8(s).toString(16)}`));return}if(l=r.getUint8(s+1),n&&console.log(`Marker: ${l.toString(16)}`),l===226){n&&console.log("Found APP2 marker (0xffe2)");const f=s+4;if(r.getUint32(f)===1297106432){const h=f+4;let i;if(r.getUint16(h)===18761)i=!1;else if(r.getUint16(h)===19789)i=!0;else{a(new Error("No valid endianness marker found in TIFF header"));return}if(r.getUint16(h+2,!i)!==42){a(new Error("Not valid TIFF data! (no 0x002A marker)"));return}const M=r.getUint32(h+4,!i);if(M<8){a(new Error("Not valid TIFF data! (First offset less than 8)"));return}const y=h+M,w=r.getUint16(y,!i),v=y+2;let c=0;for(let u=v;u<v+12*w;u+=12)r.getUint16(u,!i)===45057&&(c=r.getUint32(u+8,!i));const _=y+2+w*12+4,b=[];for(let u=_;u<_+c*16;u+=16){const m={MPType:r.getUint32(u,!i),size:r.getUint32(u+4,!i),dataOffset:r.getUint32(u+8,!i),dependantImages:r.getUint32(u+12,!i),start:-1,end:-1,isFII:!1};m.dataOffset?(m.start=h+m.dataOffset,m.isFII=!1):(m.start=0,m.isFII=!0),m.end=m.start+m.size,b.push(m)}if(this.options.extractNonFII&&b.length){const u=new Blob([r]),m=[];for(const x of b){if(x.isFII&&!this.options.extractFII)continue;const I=u.slice(x.start,x.end+1,"image/jpeg");m.push(I)}t(m)}}}s+=2+r.getUint16(s+2)}})}}const ye=async p=>{const e=me(p);if(!e)throw new j("Gain map XMP metadata not found");const a=await new ue({extractFII:!0,extractNonFII:!0}).extract(p);if(a.length!==2)throw new X("Gain map recovery image not found");return{sdr:new Uint8Array(await a[0].arrayBuffer()),gainMap:new Uint8Array(await a[1].arrayBuffer()),metadata:e}},k=p=>new Promise((e,t)=>{const a=document.createElement("img");a.onload=()=>{e(a)},a.onerror=n=>{t(n)},a.src=URL.createObjectURL(p)});class Y extends oe{constructor(e,t){super(t),e&&(this._renderer=e),this._internalLoadingManager=new de}setRenderer(e){return this._renderer=e,this}setRenderTargetOptions(e){return this._renderTargetOptions=e,this}prepareQuadRenderer(){this._renderer||console.warn("WARNING: An existing WebGL Renderer was not passed to this Loader constructor or in setRenderer, the result of this Loader will need to be converted to a Data Texture with toDataTexture() before you can use it in your renderer.");const e=new ce({gainMapMax:[1,1,1],gainMapMin:[0,0,0],gamma:[1,1,1],offsetHdr:[1,1,1],offsetSdr:[1,1,1],hdrCapacityMax:1,hdrCapacityMin:0,maxDisplayBoost:1,gainMap:new A,sdr:new A});return new G({width:16,height:16,type:U,colorSpace:E,material:e,renderer:this._renderer,renderTargetOptions:this._renderTargetOptions})}async render(e,t,a,n){const r=n?new Blob([n],{type:"image/jpeg"}):void 0,o=new Blob([a],{type:"image/jpeg"});let s,g,l=!1;if(typeof createImageBitmap>"u"){const i=await Promise.all([r?k(r):Promise.resolve(void 0),k(o)]);g=i[0],s=i[1],l=!0}else{const i=await Promise.all([r?createImageBitmap(r,{imageOrientation:"flipY"}):Promise.resolve(void 0),createImageBitmap(o,{imageOrientation:"flipY"})]);g=i[0],s=i[1]}const f=new A(g||new ImageData(2,2),B,T,T,C,N,L,P,1,E);f.flipY=l,f.needsUpdate=!0;const h=new A(s,B,T,T,C,N,L,P,1,le);h.flipY=l,h.needsUpdate=!0,e.width=s.width,e.height=s.height,e.material.gainMap=f,e.material.sdr=h,e.material.gainMapMin=t.gainMapMin,e.material.gainMapMax=t.gainMapMax,e.material.offsetHdr=t.offsetHdr,e.material.offsetSdr=t.offsetSdr,e.material.gamma=t.gamma,e.material.hdrCapacityMin=t.hdrCapacityMin,e.material.hdrCapacityMax=t.hdrCapacityMax,e.material.maxDisplayBoost=Math.pow(2,t.hdrCapacityMax),e.material.needsUpdate=!0,e.render()}}class we extends Y{load([e,t,a],n,r,o){const s=this.prepareQuadRenderer();let g,l,f;const h=async()=>{if(g&&l&&f){try{await this.render(s,f,g,l)}catch(d){this.manager.itemError(e),this.manager.itemError(t),this.manager.itemError(a),typeof o=="function"&&o(d),s.disposeOnDemandRenderer();return}typeof n=="function"&&n(s),this.manager.itemEnd(e),this.manager.itemEnd(t),this.manager.itemEnd(a),s.disposeOnDemandRenderer()}};let i=!0,M=0,y=0,w=!0,v=0,c=0,F=!0,_=0,b=0;const u=()=>{if(typeof r=="function"){const d=M+v+_,Q=y+c+b,q=i&&w&&F;r(new ProgressEvent("progress",{lengthComputable:q,loaded:Q,total:d}))}};this.manager.itemStart(e),this.manager.itemStart(t),this.manager.itemStart(a);const m=new D(this._internalLoadingManager);m.setResponseType("arraybuffer"),m.setRequestHeader(this.requestHeader),m.setPath(this.path),m.setWithCredentials(this.withCredentials),m.load(e,async d=>{if(typeof d=="string")throw new Error("Invalid sdr buffer");g=d,await h()},d=>{i=d.lengthComputable,y=d.loaded,M=d.total,u()},d=>{this.manager.itemError(e),typeof o=="function"&&o(d)});const x=new D(this._internalLoadingManager);x.setResponseType("arraybuffer"),x.setRequestHeader(this.requestHeader),x.setPath(this.path),x.setWithCredentials(this.withCredentials),x.load(t,async d=>{if(typeof d=="string")throw new Error("Invalid gainmap buffer");l=d,await h()},d=>{w=d.lengthComputable,c=d.loaded,v=d.total,u()},d=>{this.manager.itemError(t),typeof o=="function"&&o(d)});const I=new D(this._internalLoadingManager);return I.setRequestHeader(this.requestHeader),I.setPath(this.path),I.setWithCredentials(this.withCredentials),I.load(a,async d=>{if(typeof d!="string")throw new Error("Invalid metadata string");f=JSON.parse(d),await h()},d=>{F=d.lengthComputable,b=d.loaded,_=d.total,u()},d=>{this.manager.itemError(a),typeof o=="function"&&o(d)}),s}}class ve extends Y{load(e,t,a,n){const r=this.prepareQuadRenderer(),o=new D(this._internalLoadingManager);return o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setPath(this.path),o.setWithCredentials(this.withCredentials),this.manager.itemStart(e),o.load(e,async s=>{if(typeof s=="string")throw new Error("Invalid buffer, received [string], was expecting [ArrayBuffer]");const g=new Uint8Array(s);let l,f,h;try{const i=await ye(g);l=i.sdr,f=i.gainMap,h=i.metadata}catch(i){if(i instanceof j||i instanceof X)console.warn(`Failure to reconstruct an HDR image from ${e}: Gain map metadata not found in the file, HDRJPGLoader will render the SDR jpeg`),h={gainMapMin:[0,0,0],gainMapMax:[1,1,1],gamma:[1,1,1],hdrCapacityMin:0,hdrCapacityMax:1,offsetHdr:[0,0,0],offsetSdr:[0,0,0]},l=g;else throw i}try{await this.render(r,h,l,f)}catch(i){this.manager.itemError(e),typeof n=="function"&&n(i),r.disposeOnDemandRenderer();return}typeof t=="function"&&t(r),this.manager.itemEnd(e),r.disposeOnDemandRenderer()},a,s=>{this.manager.itemError(e),typeof n=="function"&&n(s)}),r}}export{we as G,ve as H};
